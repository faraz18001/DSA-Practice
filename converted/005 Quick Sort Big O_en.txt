Now, let's look at quick sort.
Big O.
Let's bring up our list here.
So the first step with quick sort is to run pivot when we run pivot.
Our list ends up looking like this.
And if you'll recall in the pivot function, we had a for loop that went all the way through the list
looking at each item.
That process of running pivot is going to be over of in.
But the recursive part, we've done one step here.
Here's two steps and three steps.
So let's say we have approximately eight items here, and we did this in three steps two to the third
power is eight.
We've seen this before.
That's oh of log in.
So quick sort is oh of in times, log in, just like Merge sort.
And on the graph, that is much more efficient.
Then, oh, then squared.
But the end times log in for quick short is actually just for the best case.
And the average case.
The worst case is not in times like yet, so let's take a look at that.
Our worst case is if we already have sorted data, so we start out with our pivot point being that one,
we're not going to move anything else in the graph and that one is going to be sorted.
And normally we run quick, short on everything on the left and everything on the right.
But we only have items on the right.
So we're going to run pivot on everything else again, remember, pivot is a wave in, so we're going
to do this again.
And then we're going to do it again all the way down.
So we're running that pivot function on every single item so that our VIN function pivot.
We're running it in times in order to get this sorted.
And other words, this is a way of in squared.
If you have already sorted data.
So, oh, of in squared is actually the worst case with quick sort.
So long as you don't have sort of data, you know you're going to have data that is very out of order.
You can count on it running in in times, log in times.
But if you have sorted data, it might be better to use something like insertion sort.
So we saw earlier that insertion sort is generally, oh, events squared, but the best possible scenario
for insertion sort is a wave in.
So that becomes one of the things you have to consider when you're looking at sorting algorithm Big
L.
