Now let's look at graph Bigo.
So I'm going to bring up the same graph that we've used in the last couple of videos here.
And we're going to represent this graph with an adjacency matrix and also an adjacency list.
These are two different ways of representing that graph.
So the first thing we'll look at is space complexity between the two of these.
So with an adjacency list, we represent the Vertex A like this, and then the edges it has with B and
E.
So we represent those in the adjacency matrix with those items I just highlighted in green.
So a huge difference between an adjacency list and an adjacency matrix is that in a matrix, each vertex
has to store all of the vertices it is not connected to.
We have to store all these zeros.
So from a space complexity standpoint, the adjacency matrix is the number of vertices squared.
Where the adjacency list is, the number of vertices, plus the number of edges.
So now let's bring back our graph.
So now let's look at the big O for the common operations that we're going to do with the graph.
First, we'll look at adding a vertex and this is just the vertex.
We're not connecting it to anything.
We haven't added any edges.
So let's bring these back up.
And with an adjacency list adding that vertex, you just do it like that.
Very simple.
With an adjacency matrix, this is much more complex.
Adding a new row, adding a new column.
In fact, it is o of the number of vertices squared.
You're basically rewriting the entire matrix.
But with the adjacency list, it's o of one.
So this is a huge difference between the adjacency matrix and the adjacency list.
So now let's bring our graph back.
And what we're going to do next is add an edge.
So let's bring these back up and adding an edge.
In this case, it was between F and B.
Is we append an F here.
We append a B here.
Pretty easy with the adjacency matrix.
We change that to a one.
We change that to a one.
So in this case, both of these are o of one.
Now let's bring back our graph.
The next step will be removing the edge between B and F.
So let's bring these back up.
So to remove the edge between B and F.
We're going to go to B and then we're going to go through that list of all the edges, find the F and
remove it.
Then we're going to come down here.
And look for all the edges here that are be.
And remove that.
With a matrix.
We're going to change that to a zero.
We're going to change that to a zero.
So to compare these, the matrix is o of one.
This is a win for the Matrix where the list we're having to iterate through the list of edges that's
associated with each one of those vertices.
So it's o of the number of edges that we have to go through.
So let's bring our graph back here.
And the next thing is we're going to remove the vertex.
So let's bring these back up.
So if we're going to remove a vertex, it looks simple that we're just going to do that.
But we also have to remove all of the other edges.
So the vertex A could have an edge with F, So we have to go through this list.
Then we have to come down to the next vertex and then go through this list.
In other words, we're going to need to touch everything in this dictionary.
With a matrix.
In order to remove that vertex, we have to do this, which is basically rewriting the entire matrix.
So the matrix is going to be the number of vertices squared.
Where the list on the right is the number of vertices, plus the number of edges.
Now, with the adjacency list, if you have bidirectional connections, there's an efficiency in how
you can write your method that makes this more efficient.
So let's focus in on this matrix and make another point about this.
We had mentioned earlier that we're not only storing the ones, we're also storing the zeros.
And this is not a big deal when you have a small graph.
But imagine that your Facebook and let's just say for easy figuring, you have a billion users, which
is a billion vertices.
So each axis, the horizontal axis and the vertical axis are going to be a billion items.
Even if each person on Facebook has 1000 friends, you are going to be storing a million zeros for every
one.
So it's incredibly inefficient from a storage perspective.
Whereas with an adjacency list, we don't have to store all of those zeros.
So this is what we're going to use in this course.
It is much simpler.
It is much more efficient.
And that is our overview of graph.
Big O.
