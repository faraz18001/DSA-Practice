So now we're going to start writing our code for delete node and we'll start our code off like this.
And this has that same double underscore that we had for recursive contains and recursive insert.
And for the same reason we have to pass this the root to get this kicked off.
And we do that with this method.
And this method will call the double underscore method with the root and the value.
We'll bring in this binary search tree and a call stack.
And I'll add an instance of delete node to the call stack called on the root.
What we're going to start out with here is trying to delete the number 18, so something that is not
in the tree.
So we'll look at how this works when the number that we're looking for is not in the tree and then we'll
delete the number 21 to see how this works.
When the number is in the tree that we're trying to delete.
So one of the things that's interesting about this method is how much similarity it has to the insert
method.
So just like with the insert method, we're going to start this out by saying if the value that we're
looking to delete is less than current node value, then we'll set current node left to be equal to
delete node on current node left.
And current node left is that 21 node.
So we'll add that to the call stack.
And this new instance will also be past the value that we're trying to delete, in this case 18.
And now this is the active instance on the call stack.
So we'll say if value the value of 18, if it is less than current node value and current node value
is 21, then we're going to set current node left to be equal to delete node on current node left.
And current node left is none.
So we're calling an instance on none.
And this is our base case.
And we'll say if current node is equal to none, we're going to return none.
And to this point, this line here is the first thing that is different from the insert method.
And it's going to return none to the calling method is going to return it to here.
And this instance gets popped from the call stack.
So this is the active instance and this is the last line that it ran.
And specifically, this part of this line of code called that instance that was just popped from the
call stack.
So when it returned none, it was returning it specifically to here.
So we set current node left to be equal to none, which it already is.
This doesn't change anything.
Then we return current node.
And just like with the insert method that's going to work like this, it's going to return a pointer
to this node.
And once it returns that, this is popped from the call stack.
And now this is the active instance.
Again, this is the last line that this instance ran.
This part of this line called that instance that was just popped from the call stack that returned this
pointer to the 21 node.
So we're setting current node left to be equal to this 21 node, which keeps everything exactly the
way that it was.
So now this instance needs to return current node.
And it's going to return this to the calling method, which is this method here.
It's going to return it to here.
And when it does that, this is popped from the call stack.
So everything we did here, we traverse to the left with this code.
We also need to be able to traverse to the right.
So we'll add this code.
This is almost identical, except that we have a greater than here instead of a less than.
And we're going to go right instead of left.
So now let's look at deleting a node that is in the tree.
We're going to delete the 21 node.
And just like we always do, we'll kick this off with an instance called On the Root.
So 21 is less than current node value.
So we'll call an instance on the 21 node.
And this is the value that we want to delete.
So this is the active instance.
We'll start at the top.
If current node is equal to none, that is not the case.
Current node is the 21 node.
But because.
Has the value that we're trying to delete is equal to current node value.
It is not less than and it is not greater than.
So we have to have an additional option here and we'll say else.
And most of the code in this method will exist within this statement.
There are four different situations within this statement that we have to code for.
We have to code for this situation where we're deleting a leaf node.
We have to code for when we have an opening on the left, but a node on the right.
Then we need to code for when we have a node on the left and an opening on the right.
And then we need to code for when we have nodes on each side of the node that we're deleting.
And the next video, we're going to code for all three of these situations.
These are going to be the easy ones.
Then we're going to have two videos to code for this situation.
First, we're going to write a helper method and then we'll actually write the code to delete the 21
node in this situation.
But like I said, first we're going to write all three of these in the next video.
But for now, this concludes Delete Node Part one.
